import {
  $update,
  $query,
  Record,
  StableBTreeMap,
  Vec,
  match,
  Result,
  nat64,
  ic,
  Opt,
  Principal,
  nat,
} from "azle";
import { v4 as uuidv4 } from "uuid";

type FoodItem = Record<{
  id: string;
  name: string;
  quantity: nat;
  expirationDate: nat64;
  ownerId: Principal;
  createdAt: nat64;
  updatedAt: Opt<nat64>;
}>;


type FoodItemPayload = Record<{
  name: string;
  quantity: nat;
  expirationDate: nat64;
}>;

const foodItemStorage = new StableBTreeMap<string, FoodItem>(0, 44, 1024);

const sharedCommunityList: FoodItem[] = [];


// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
  return str.trim().length == 0
}

// Helper function to ensure the input id meets the format used for ids generated by uuid
function isValidUuid(id: string): boolean {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}

/**
 * Helper function to validate the FoodItemPayload
 * Ensures the following conditions are met:
 * 1. The title is not empty
 * 2. The description is not empty
 */
function validateFoodItemPayload(payload: FoodItemPayload): Vec<string>{
  const errors: Vec<string> = [];
  if (isInvalidString(payload.name)){
      errors.push(`name='${payload.name}' cannot be empty.`)
  }
  if(payload.quantity == BigInt(0)){
    errors.push("Quantity cannot be set to zero")
  }
  if(payload.expirationDate <= ic.time()){
    errors.push("Only food items with an expiration date greater than the current timestamp can be listed.")
  }
  return errors;
}

$update;
export function createFoodItem(payload: FoodItemPayload): Result<FoodItem, string> {
  let payloadErrors = validateFoodItemPayload(payload);
  if(payloadErrors.length){
    return Result.Err(`Input validations failed. Errors=[${payloadErrors}]`)
  }
  const foodItem: FoodItem = {
    id: uuidv4(),
    createdAt: ic.time(),
    updatedAt: Opt.None,
    ownerId: ic.caller(),
    ...payload,
  };

  foodItemStorage.insert(foodItem.id, foodItem);
  return Result.Ok<FoodItem, string>(foodItem);
}


$query;
export function getFoodItemById(id: string): Result<FoodItem, string> {
  if (!isValidUuid(id)){
    return Result.Err(`id=${id} is not in the valid uuid format`)
  }
  return match(foodItemStorage.get(id), {
    Some: (item) => Result.Ok<FoodItem, string>(item),
    None: () => Result.Err<FoodItem, string>(`Food Item with ID=${id} not found.`),
  });
}

$query;
export function getFoodItemsByName(name: string): Result<Vec<FoodItem>, string> {
  if(isInvalidString(name)){
    return Result.Err("Name cannot be empty")
  }
  const matchingItems = foodItemStorage.values().filter((item) => item.name.toLowerCase() === name.toLowerCase());
  return Result.Ok(matchingItems);
}

$query;
export function getAllFoodItems(): Result<Vec<FoodItem>, string> {
  const currentUserId = ic.caller().toString();
  const userFoodItems = foodItemStorage.values().filter((item) => item.ownerId.toString() === currentUserId);
  return Result.Ok(userFoodItems);
}

$update;
export function updateFoodItem(id: string, payload: FoodItemPayload): Result<FoodItem, string> {
  if (!isValidUuid(id)){
    return Result.Err(`id=${id} is not in the valid uuid format`)
  }
  return match(foodItemStorage.get(id), {
    Some: (existingItem) => {
      if(existingItem.ownerId.toString() !== ic.caller().toString()){
        return Result.Err<FoodItem,string>("Caller is not the ownerId of the food item")
      }
      let payloadErrors = validateFoodItemPayload(payload);
      if(payloadErrors.length){
        return Result.Err<FoodItem,string>(`Input validations failed. Errors=[${payloadErrors}]`)
      }
      const updatedItem: FoodItem = {
        ...existingItem,
        ...payload,
        updatedAt: Opt.Some(ic.time()),
      };

      foodItemStorage.insert(updatedItem.id, updatedItem);
      return Result.Ok<FoodItem, string>(updatedItem);
    },
    None: () => Result.Err<FoodItem, string>(`Food Item with ID=${id} not found.`),
  });
}

$update;
export function deleteFoodItem(id: string): Result<FoodItem, string> {
  if (!isValidUuid(id)){
    return Result.Err(`id=${id} is not in the valid uuid format`)
  }
  return match(foodItemStorage.get(id), {
    Some: (existingItem) => {
      if(existingItem.ownerId.toString() !== ic.caller().toString()){
        return Result.Err<FoodItem,string>("Caller is not the ownerId of the food item")
      }
      foodItemStorage.remove(id);
      return Result.Ok<FoodItem, string>(existingItem);
    },
    None: () => Result.Err<FoodItem, string>(`Food Item with ID=${id} not found.`),
  });
}

$update;
export function shareExcessFood(id: string): Result<FoodItem, string> {
  if (!isValidUuid(id)){
    return Result.Err(`id=${id} is not in the valid uuid format`)
  }
  return match(foodItemStorage.get(id), {
    Some: (foodItem) => {
      if(foodItem.ownerId.toString() !== ic.caller().toString()){
        return Result.Err<FoodItem,string>("Caller is not the ownerId of the food item")
      }
      foodItemStorage.remove(id);
      sharedCommunityList.push(foodItem);
      return Result.Ok<FoodItem, string>(foodItem);
    },
    None: () => Result.Err<FoodItem, string>(`Food Item with ID=${id} not found.`),
  });
}

$query;
export function getAllSharedFoodItems(): Result<Vec<FoodItem>, string> {
  return Result.Ok(sharedCommunityList);
}

// ...

$update;
export function updateFoodItemQuantity(id: string, newQuantity: nat): Result<FoodItem, string> {
  if (!isValidUuid(id)){
    return Result.Err(`id=${id} is not in the valid uuid format`)
  }
  return match(foodItemStorage.get(id), {
    Some: (existingItem) => {
      if(existingItem.ownerId.toString() !== ic.caller().toString()){
        return Result.Err<FoodItem,string>("Caller is not the ownerId of the food item")
      }
      const updatedItem: FoodItem = {
        ...existingItem,
        quantity: newQuantity,
        updatedAt: Opt.Some(ic.time()),
      };

      foodItemStorage.insert(updatedItem.id, updatedItem);
      return Result.Ok<FoodItem, string>(updatedItem);
    },
    None: () => Result.Err<FoodItem, string>(`Food Item with ID=${id} not found.`),
  });
}

$query;
export function getFoodItemsByQuantity(minQuantity: number, maxQuantity: number): Result<Vec<FoodItem>, string> {
  const matchingItems = foodItemStorage.values().filter(
    (item) => item.quantity >= minQuantity && item.quantity <= maxQuantity
  );
  return Result.Ok(matchingItems);
}

// ...


globalThis.crypto = {
  // @ts-ignore
  getRandomValues: () => {
    let array = new Uint8Array(32);
    for (let i = 0; i < array.length; i++) {
      array[i] = Math.floor(Math.random() * 256);
    }
    return array;
  },
};
